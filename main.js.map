{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/instrument.js","webpack:///./src/gui.js","webpack:///./src/index.js","webpack:///./src/style.css","webpack:///./src/style.css?7528"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAiB,4BAA4B;AAC7C;AACA;AACA,0BAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAgB,uBAAuB;AACvC;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIgD;AAChD;AACA;AACqB;;AAErB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB;AACA,UAAU,OAAO;AACjB;AACA,UAAU,SAAS;AACnB,UAAU,SAAS;AACnB;AACA,UAAU,OAAO;AACjB;AACA,UAAU,SAAS;AACnB,UAAU,OAAO;AACjB;AACA,UAAU,OAAO;AACjB;AACA,UAAU,SAAS;AACnB;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;;;;;ACvMA;AACA;AACA;AACa;;AAEb;AACqC;;AAErC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,C;;ACxIkE;AACrC;AAC7B;AACqB;;AAErB;AAC4C;;AAE5C,KAAK,yLAA8E;;AAEnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,yB;;;;;;;AC7JA;AACA;;;AAGA;AACA,wCAAyC,qBAAqB,2BAA2B,sBAAsB,qBAAqB,qBAAqB,iCAAiC,KAAK,8BAA8B,mBAAmB,kBAAkB,KAAK,4BAA4B,0BAA0B,KAAK,0BAA0B,oBAAoB,qBAAqB,2BAA2B,KAAK;;AAEra;;;;;;;;;ACNA;;AAEA;;AAEA;AACA;;;;AAIA,eAAe;;AAEf;AACA;;AAEA;;AAEA;;AAEA,Y","file":"main.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t1: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([34,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import { Transport, Time, Event, Draw, context } from 'tone'\r\nimport Noise from 'noisejs'\r\nimport Perlin from \"proc-noise\"\r\nimport {randomNormal} from 'd3-random'\r\n\r\nexport function toSecs(notation) {\r\n    return Time(notation).toSeconds()\r\n}\r\n\r\n// let noise = new Noise(Math.random())\r\nlet perlin = new Perlin(Math.random())\r\n\r\nfunction timeMap(start, length, from, to) {\r\n    to = typeof to === 'undefined' ? 1 : to\r\n    from = from || 0\r\n\r\n    return Math.min(to, Math.max(from + to * (Date.now() - start) / length, from))\r\n}\r\n/**@param {String[]} chordArr\r\n * @param {Function} dist\r\n * @param {Number} [baseVal]\r\n * @return {String}\r\n */\r\nexport function distToNote(chordArr, dist, baseVal) {\r\n    baseVal = baseVal || 0\r\n\r\n    return floatToNote(chordArr, dist() + baseVal)\r\n}\r\n\r\n/**@param {Number[]} chordArr\r\n * @param {String} val\r\n * @return {String}\r\n */\r\nexport function floatToNote(chordArr, val) {\r\n    let octave = Math.floor(val)\r\n    let i = Math.floor((val - octave) * chordArr.length)\r\n\r\n    return chordArr[i] + String(octave)\r\n}\r\n\r\nexport function seconds() {\r\n    return Transport.seconds\r\n}\r\n\r\nexport function waitForTime(time) {\r\n    return new Promise(resolve => Transport.schedule(resolve, time));\r\n}\r\n\r\nfunction newSeed(){\r\n    return Math.random() * 99999\r\n}\r\n\r\n/**\r\n * @typedef {Object} RepeaterOptions\r\n * \r\n * @prop {Function} [getProbability]\r\n * @prop {Number} [probability]\r\n * \r\n * @prop {String} [quantize]\r\n * \r\n * @prop {String[]} [notes]\r\n * @prop {Function} [getNote]\r\n * \r\n * @prop {String} [note]\r\n * \r\n * @prop {Function} [getLength]\r\n * @prop {String} [length]\r\n * \r\n * @prop {String} [snap] snap the start of each note\r\n * \r\n * @prop {Function} onDraw\r\n * \r\n */\r\n\r\nexport class Repeater {\r\n    /**\r\n     * @param instrument\r\n     * @param {RepeaterOptions} options\r\n     */\r\n    constructor(instrument, options) {\r\n        let {quantize} = options;\r\n        this.note = options.note;\r\n        this.notes = options.notes;\r\n\r\n        this.note = options.note\r\n\r\n        let getLength = options.length ? () => options.length : \r\n            options.getLength\r\n\r\n        let getProbability = options.probability ? () => options.probability : \r\n            options.getProbability\r\n\r\n        let getNote = this.note ? () => this.note : \r\n        this.notes ? () => floatToNote(this.notes, options.getNote()) : \r\n                options.getNote\r\n\r\n        let seed = newSeed()\r\n        instrument.sync()\r\n        this.instrument = instrument\r\n\r\n        //transport callback\r\n        let playNote = function (time) {\r\n            let length = Math.max(0, getLength())\r\n\r\n            //quantize if exists\r\n            if (quantize){\r\n                length = Time(length).quantize(quantize)\r\n                if(length <= 0){\r\n                    length = toSecs(quantize)\r\n                }\r\n            }\r\n\r\n            if (Math.random() < getProbability() && 0 < length) {\r\n                let note = getNote()\r\n                // if(this.debug) console.log(note + ', ' + Time(length).toNotation())\r\n                instrument.triggerAttackRelease(note, length, time)\r\n                \r\n                Draw.schedule(() => {\r\n                    if(options.onDraw) options.onDraw(time, length, note, instrument.envelope)\r\n                    if(this.debug) console.log(note + ', ' + Time(length).toNotation())\r\n                }, time+context.lookAhead)\r\n                // if(options.onDraw) options.onDraw(time+context.lookAhead, length, note, instrument.envelope)\r\n\r\n            } else if(this.debug){\r\n                if(length <= 0)\r\n                    console.log(\"%cZERO LENGTH\", 'color: red')\r\n\r\n                console.log('| ' + Time(length).toNotation())\r\n            }\r\n            return length\r\n\r\n            // this.id = Transport.schedule(playNote, length + time - context.lookAhead)\r\n        }.bind(this)\r\n\r\n        let buffer = 0.5;\r\n\r\n        let minSecs = toSecs(quantize || \"64n\")\r\n\r\n        let processTime = 0;\r\n        let process = (time) => {\r\n            \r\n            //repeat till fills buffer time\r\n            while(processTime < time+buffer){\r\n                //jump up if behind\r\n                if(processTime < time){\r\n                    processTime = time+buffer\r\n                }\r\n\r\n                let length = playNote(processTime);\r\n                if(length < minSecs)\r\n                    length = minSecs\r\n\r\n                processTime += length\r\n            }\r\n        }\r\n\r\n        process(0)\r\n        Transport.scheduleRepeat(process, \"64n\")\r\n\r\n        //start it\r\n        // this.id = Transport.schedule(process, 0)\r\n    }\r\n\r\n    Cancel() {\r\n        Transport.clear(this.id)\r\n        this.instrument.volume.value = 0\r\n        return this\r\n    }\r\n\r\n    Debug(){\r\n        this.debug = true\r\n        return this\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {Number} speed in seconds\r\n * @param {Number} [width] \r\n * @param {Number} [start] \r\n */\r\nexport function perlinNoise(speed, start, width, seed) {\r\n    width = width || 1\r\n    start = start || 0\r\n    seed = seed || newSeed()\r\n    return () => start + perlin.noise(seed + seconds() * speed) * width\r\n}\r\n\r\n/**\r\n * \r\n * @param {Function} getMean \r\n * @param {Number} dev \r\n */\r\nexport function movingMean(getMean, dev) {\r\n    return () => randomNormal(getMean(), dev)()\r\n}\r\n\r\nexport function staticReturn(val) {\r\n    return () => val;\r\n}","import JSONEditor from 'jsoneditor'\r\nimport 'jsoneditor/dist/jsoneditor.min.css'\r\nimport './style.css'\r\nimport {Note} from 'tonal'\r\n\r\nimport Perlin from \"proc-noise\"\r\nimport {perlinNoise, seconds, toSecs} from './instrument'\r\n\r\nlet perlin = new Perlin(Math.random())\r\n\r\nimport P5 from 'p5'\r\n\r\nconst p5 = new P5(p5 => {\r\n    p5.setup = () => {\r\n        let canvas = p5.createCanvas(p5.windowWidth, p5.windowHeight)\r\n        p5.windowResized()\r\n        canvas.parent(\"p5Container\")\r\n        // p5.setAttributes('antialias', true);\r\n\r\n        p5.colorMode(p5.HSB)\r\n        p5.ellipseMode(p5.RADIUS)\r\n    }\r\n\r\n    p5.draw = () => {\r\n        p5.fill(0, 0, 100)\r\n        draws.forEach(draw => draw(p5))\r\n    }\r\n\r\n    p5.windowResized = () => {\r\n        p5.resizeCanvas(p5.windowWidth, p5.windowHeight)\r\n        p5.background(0,0,0)\r\n    }\r\n})\r\n\r\nlet draws = []\r\n\r\nexport function circleDrawer(maxRadius, backgroundOnChange, middleWidth){\r\n    let changed = false;\r\n\r\n    let start;\r\n    let length;\r\n    let getX;\r\n    let getY;\r\n    let note;\r\n    let envelope;\r\n\r\n    let pulse = toSecs(\"8n\");\r\n    \r\n    maxRadius = maxRadius || 100;\r\n\r\n    draws.push(p5 => {\r\n        if(!start)\r\n            return\r\n            \r\n        let progress = (seconds()-start)/length\r\n\r\n        if(progress < 0)\r\n            return\r\n\r\n        let x = getX()\r\n        let y = getY()\r\n\r\n        if(changed && backgroundOnChange){\r\n            p5.noStroke()\r\n            p5.fill(0, 0, 0, 0.5)\r\n            // p5.ellipse(x, y, maxRadius, maxRadius)\r\n            p5.background(0,0,0, backgroundOnChange)\r\n            changed = false;\r\n        }\r\n\r\n        if(1 < progress)\r\n            return\r\n\r\n        let val = envelope ? envelope.value : 1-progress*0.2+0.03*Math.sin(seconds()/pulse*Math.PI-Math.PI)\r\n        let radius = maxRadius*val\r\n\r\n        let color = p5.color(note*360%360, 100*val, 90)\r\n        \r\n        p5.strokeWeight(7)\r\n        p5.stroke(color)\r\n        p5.noFill()\r\n        p5.ellipse(x, y, radius, radius)\r\n\r\n        if(middleWidth){\r\n            p5.noStroke()\r\n            p5.fill('white')\r\n            p5.ellipse(x, y, middleWidth, middleWidth)\r\n        }\r\n    })\r\n\r\n    return (newStart, newLength, newNote, newEnvelope) => {\r\n        changed = true\r\n        length = newLength\r\n        start = newStart\r\n        envelope = newEnvelope\r\n\r\n        note = ( Note.midi(newNote) || newNote.reduce((prev, note) => prev+Note.midi(note), 0)/newNote.length )/12\r\n        \r\n        let speed = note*note*0.002\r\n        getX = perlinNoise(speed, 0, p5.windowWidth, note*9999)\r\n        getY = perlinNoise(speed, 0, p5.windowHeight, note*19999)\r\n    }\r\n}\r\n\r\nexport default class SynthEditor{\r\n\r\n    /**\r\n     * @param {HTMLElement|String} container\r\n     * @param synth\r\n     */\r\n    constructor(container, synth){\r\n        if(typeof container == 'string'){\r\n            container = document.getElementById(container)\r\n        }\r\n\r\n        let options = synth.get()\r\n\r\n        let editor = new JSONEditor(container, {\r\n            mode: 'form',\r\n            onChange: () => {\r\n                try{\r\n                    let newOpts = editor.get();\r\n                    \r\n                    synth.set(newOpts)\r\n                    options = newOpts\r\n                    console.log(\"JSON Applied\")\r\n                } catch(err) {\r\n                    synth.set(options)\r\n                    // console.log(err)\r\n                    // melodySynth.set(melodySynthOpts)\r\n                }\r\n            }\r\n        }, options);\r\n\r\n        editor.expandAll()\r\n    }\r\n}","import Tone, { MembraneSynth, FMSynth, Transport, Synth, context } from 'tone'\r\nimport { Scale, Chord, Note } from 'tonal'\r\nimport * as Key from 'tonal-key'\r\nimport {randomNormal} from 'd3-random'\r\n\r\nimport * as Instrument from './instrument'\r\nimport SynthEditor, {doCircle, circleDrawer} from './gui'\r\n\r\nvar {staticReturn, perlinNoise, Repeater, floatToNote, toSecs, movingMean, seconds} = Instrument;\r\n\r\n//visual logic\r\nlet bases = Note.names(\" b\")\r\nlet key = bases[Math.floor(bases.length*Math.random())] + (Math.random()<0.5 ? \" minor\" : \" major\")\r\nconsole.log(\"Key: \" + key)\r\nlet chords = Key.chords(key)\r\n\r\nlet i = 0;\r\nlet progressions = [[4,5,1], [2,5,1], [5,2,1], [3,2,1], [3,4,1]]\r\nlet progression = progressions[Math.floor(progressions.length*Math.random())]\r\n\r\nlet chord = Chord.notes(chords[progression[0]])\r\n\r\nTransport.scheduleRepeat(time => {\r\n    let newInt = progression[i]-1;\r\n    i++;\r\n    if(i == progression.length){\r\n        progression = progressions[Math.floor(progressions.length*Math.random())]\r\n        i = 0\r\n    }\r\n    // let chord = Note.simplify(chords[newInt]) + \" minor blues\"\r\n    // console.log(\"CHORD: \" + chord)\r\n    // notes = Scale.notes(chord).map(Note.simplify).map(note => note)\r\n    console.log(\"Chord: \" + chords[newInt])\r\n    chord = Chord.notes(chords[newInt])\r\n}, \"4m\")\r\n\r\nlet notes = Scale.notes(key + ' blues')\r\nconsole.log(\"notes: \" + notes)\r\n\r\nfunction getRandom(arr, n) {\r\n    var result = new Array(n),\r\n        len = arr.length,\r\n        taken = new Array(len);\r\n    if (n > len)\r\n        throw new RangeError(\"getRandom: more elements taken than available\");\r\n    while (n--) {\r\n        var x = Math.floor(Math.random() * len);\r\n        result[n] = arr[x in taken ? taken[x] : x];\r\n        taken[x] = --len in taken ? taken[len] : len;\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\nTransport.bpm.value = 70+50*Math.random();\r\n\r\n//synthesisers\r\n\r\nvar melodySynth = new FMSynth({\r\n    \"harmonicity\": 8,\r\n    \"modulationIndex\": 10,\r\n    \"oscillator\": {\r\n        \"type\": \"square\"\r\n    },\r\n    \"envelope\": {\r\n        \"attack\": 0.01,\r\n        \"decay\": 1,\r\n        \"sustain\": 0.1,\r\n        \"release\": 2\r\n    },\r\n    \"modulation\": {\r\n        \"type\": \"square\"\r\n    },\r\n    \"modulationEnvelope\": {\r\n        \"attack\": 0.002,\r\n        \"decay\": 0.2,\r\n        \"sustain\": 0,\r\n        \"release\": 0.2\r\n    }\r\n}).toMaster()\r\n\r\nvar kickEff = new Tone.Distortion(0.2).toMaster();\r\nvar kickSynth = new MembraneSynth({\r\n    octaves: 6,\r\n    pitchDecay: toSecs(\"8n\"),\r\n    \"envelope\": {\r\n        \"attack\": 0.2,\r\n        \"attackCurve\": 'exponential',\r\n        \"release\": 0.1\r\n    }\r\n})\r\nkickSynth.connect(kickEff)\r\n\r\nlet cymbalSynth = new Tone.MetalSynth({\r\n    \r\n}).toMaster()\r\n\r\nlet effect = new Tone.Chorus(1/toSecs('4n'), 1/toSecs('2n'), 0.6).toMaster();\r\nlet bassSynth = new Tone.PolySynth(4, Tone.AMSynth)\r\nbassSynth.set({\r\n    harmonicity: 1,\r\n    oscillator: {\r\n        type: 'sine'\r\n    }\r\n})\r\nbassSynth.connect(effect)\r\n\r\nlet editor = new SynthEditor(\"jsoncontainer\", kickSynth)\r\n\r\n//instrument controllers\r\n\r\nlet percussionProb = perlinNoise(0.5, 0, 1)\r\n\r\nnew Instrument.Repeater(kickSynth, {\r\n    note: \"C1\",\r\n    getLength: randomNormal(toSecs(\"8n\"), toSecs(\"4n\")),\r\n    quantize: '8n',\r\n    getProbability: percussionProb,\r\n    probability: 1\r\n}).Debug()\r\n\r\nnew Instrument.Repeater(cymbalSynth, {\r\n    note: \"C1\",\r\n    getLength: randomNormal(toSecs(\"8n\"), toSecs(\"4n\")),\r\n    quantize: '8n',\r\n    getProbability: percussionProb,\r\n    probability: 1\r\n}).Debug()\r\n\r\nnew Instrument.Repeater(bassSynth, {\r\n    // notes: Chord.notes(chords[progression[0]]),\r\n    // getNote: randomNormal(2, 0.5),\r\n    getNote: () => getRandom(chord, 3).map(val => val+\"3\"),\r\n    probability: 1,\r\n    getLength: randomNormal(toSecs(\"1m\"), toSecs(\"2n.\")),\r\n    quantize: '4n',\r\n    onDraw: circleDrawer(null, 0.2, 1.5)\r\n})\r\n\r\nnew Instrument.Repeater(melodySynth, {\r\n    notes: notes,\r\n    getNote: movingMean(perlinNoise(0.1, 2.5, 4), 0.5),\r\n    // getNote: perlinNoise(3, 3, 1),\r\n    // getNote: () => seconds()/3,\r\n    getProbability: perlinNoise(0.4, 0.4, 0.6),\r\n    // probability: 1,\r\n    getLength: movingMean(perlinNoise(0.4, toSecs(\"16n\"), toSecs(\"4n\")), toSecs(\"8n\")),\r\n    // length: toSecs('8n'),\r\n    // quantize: '16n',\r\n    // snap: \"8n\",\r\n    onDraw: circleDrawer(50)\r\n})\r\n\r\nTransport.swing = 1\r\ncontext.latencyHint = process.env.NODE_ENV == \"production\" ? \"playback\" : \"balanced\"\r\n\r\n//also starts transport\r\nTransport.start()","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"#jsoncontainer{\\r\\n    width: 400px;\\r\\n    position: absolute;\\r\\n    padding: 10px;\\r\\n    opacity: 0.4;\\r\\n    left: -400px;\\r\\n\\r\\n    transition: all 0.2s;\\r\\n}\\r\\n\\r\\n#jsoncontainer:hover {\\r\\n    opacity: 1;\\r\\n    left: 0px;\\r\\n}\\r\\n\\r\\n#jsoncontainer > * {\\r\\n    background: white;\\r\\n}\\r\\n\\r\\n#p5Container > * {\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n    position: absolute;\\r\\n}\", \"\"]);\n\n// exports\n","\nvar content = require(\"!!../node_modules/css-loader/index.js!./style.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./style.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./style.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}"],"sourceRoot":""}